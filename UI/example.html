<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>KB국민카드 상담 챗봇</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:'Segoe UI',system-ui,-apple-system,Roboto,Arial,"Noto Sans KR",sans-serif;background:#f4f6fb;margin:0;padding:28px;}
    .chat-wrap{max-width:860px;margin:auto;background:#fff;border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,.08);padding:22px;}
    h2{margin:0 0 16px 0;text-align:center}
    .message-row{display:flex;margin:12px 0;}
    .user{justify-content:flex-end;}
    .bot{justify-content:flex-start;}
    .bubble{max-width:78%;padding:12px 16px;border-radius:18px;font-size:15px;line-height:1.55;white-space:pre-wrap;box-shadow:0 1px 4px rgba(0,0,0,.06);}
    .user .bubble{background:#d9e6ff;border-bottom-right-radius:8px;}
    .bot .bubble{background:#eef1f6;border-bottom-left-radius:8px;}
    .bubble .content h1,.bubble .content h2,.bubble .content h3,.bubble .content h4,.bubble .content h5,.bubble .content h6{font-size:15px;font-weight:700;line-height:1.55;margin:6px 0;}
    .bubble .content ul,.bubble .content ol{margin:8px 0 8px 18px;}
    /* 비교 말풍선 */
    .bubble.comparison .content,.bubble.comparison .content p,.bubble.comparison .content li{font-weight:400;}
    .bubble.comparison .content strong,.bubble.comparison .content b{font-weight:700;}
    .bubble .actions{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    .btn{padding:8px 12px;font-size:13px;border-radius:8px;border:1px solid #cfd6e6;background:#f3f6ff;cursor:pointer;}
    .btn.primary{background:#2b61ff;border-color:#2b61ff;color:#fff;}
    .btn.ghost{background:#fff;}
    .small{font-size:12px;color:#667085;margin-top:6px;}
    .input-area{margin-top:18px;}
    textarea,select,input[type="number"],input[type="submit"]{width:100%;padding:10px;font-size:15px;border:1px solid #d7dbe8;border-radius:10px;box-sizing:border-box;}
    textarea{resize:vertical}
    .row{display:flex;gap:8px;align-items:center;}
    .row>*{flex:1}
    .row.inline{justify-content:space-between;gap:12px}
    .row.inline .left{flex:auto}
    .row.inline .right{flex:none;display:flex;gap:8px}
    .rank{font-weight:700}
    .detail{margin-top:8px;padding:10px 12px;border-radius:10px;background:#fff;border:1px solid #e6eaf5;white-space:normal}
    .pick-line{display:flex;align-items:center;gap:8px;margin-top:10px;flex-wrap:wrap}
    hr{border:none;border-top:1px solid #eceff6;margin:14px 0;}
    .pending .bubble{opacity:.8}

    /* 카드 박스 */
    .card-box{background:#f8fafc;border:1px solid #e5e9f2;border-radius:14px;padding:14px;line-height:1.7;white-space:normal;word-break:keep-all;line-break:strict}
    .card-box h4{margin:0 0 8px 0;font-size:16px}
    .card-meta{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:8px 0}
    .card-kv{display:flex;gap:8px;align-items:flex-start}
    .card-kv .k{min-width:80px;color:#556;font-weight:600}
    .card-kv .v{flex:1}
    .card-tags{display:flex;flex-wrap:wrap;gap:6px;margin:6px 0}
    .tag{font-size:12px;padding:3px 8px;border-radius:999px;background:#eef2ff}
    .card-benefits ul,.card-cond ul{margin:8px 0 0 18px}
    .fee-tags{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
    .fee{background:#fff;border:1px dashed #d9dfeb;border-radius:10px;padding:6px 10px;font-size:13px;white-space:nowrap}

    /* 이미지 */
    .bubble .content img{max-width:100%;height:auto;border-radius:10px;display:block;margin:10px 0;box-shadow:0 2px 8px rgba(0,0,0,.06);}

    @media (max-width:640px){.card-meta{grid-template-columns:1fr}}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
</head>
<body>
  <div class="chat-wrap">
    <h2>💳 KB국민카드 상담 챗봇</h2>

    <div id="chat"></div>

    <div class="input-area">
      <div class="row inline">
        <div id="selectStatus" class="small left" style="margin:6px 4px 10px 4px;">현재 선택: 없음 (추천에서 카드를 선택하세요)</div>
        <div class="right"><button id="btnRecomm" class="btn ghost" type="button">🔄 다른 카드 추천 받기</button></div>
      </div>

      <form id="ask-form" onsubmit="return false;">
        <div class="row"><textarea id="user_input" rows="3" placeholder="궁금한 내용을 입력하세요" required></textarea></div>
        <div class="row">
          <select id="card_type">
            <option value="all">전체</option><option value="credit">신용</option><option value="check">체크</option>
          </select>
          <input id="top_k" type="number" min="1" max="10" value="5" />
          <input class="btn primary" type="submit" value="전송" />
        </div>
        <div class="small">추천 및 비교 분석 → 카드 선택 → 상세 Q&A(원문 기반). 각 답변 말풍선 아래에 "이 답변을 쉽게 설명해줘 / 이 답변에 대해 질문하기"가 표시됩니다.</div>
      </form>
    </div>
  </div>

  <script>
    const chat = document.getElementById("chat");
    const form = document.getElementById("ask-form");
    const input = document.getElementById("user_input");
    const cardTypeSel = document.getElementById("card_type");
    const topK = document.getElementById("top_k");
    const selectStatus = document.getElementById("selectStatus");
    const btnRecomm = document.getElementById("btnRecomm");
    let selectedCardName = null;

    function setStatusSelected(name){ selectedCardName = name; selectStatus.textContent = `현재 선택: ${name}`; }
    function resetSelection(){ selectedCardName = null; selectStatus.textContent = "현재 선택: 없음 (추천에서 카드를 선택하세요)"; input.placeholder = "원하는 카드 조건을 적어주세요."; }

    /* ---------- 공통 렌더 ---------- */
    function compactNewlines(s){ return (s||"").replace(/\r\n/g, "\n"); }
    function escapeHtml(t){ return String(t).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    /* LaTeX → 텍스트 연산자(+ - / X) */
    function latexToPlainOps(src){
      if(!src) return src;
      let t = String(src);
      t = t.replace(/^\s*[\[\]]\s*$/gm, "");
      t = t.replace(/\\\[(.*?)\\\]/gs, "$1");
      t = t.replace(/\$\$(.*?)\$\$/gs, "$1");
      t = t.replace(/\\\((.*?)\\\)/gs, "$1");
      for(let i=0;i<5;i++) t = t.replace(/\\text\{([^{}]*)\}/g, "$1");
      for(let i=0;i<5;i++) t = t.replace(/\\frac\{([^{}]+)\}\{([^{}]+)\}/g, "$1 / $2");
      t = t.replace(/\\times|\\cdot|×/g, " X ");
      t = t.replace(/\\[a-zA-Z]+/g, "");
      t = t.replace(/\{([^{}]*)\}/g, "$1");
      // 안전: 전각 별/제로폭 제거
      t = t.replace(/\uFF0A/g,'*').replace(/[\u200B-\u200D\uFEFF]/g,'');
      return t.replace(/[ \t]+/g," ").replace(/\n{3,}/g,"\n\n").trim();
    }

    function renderMarkdown(md){
      const normalized = latexToPlainOps((md||"").replace(/\r\n/g, "\n"));
      const html = marked.parse(normalized);
      return DOMPurify.sanitize(html);
    }
    const inlineMd = s => DOMPurify.sanitize(marked.parseInline(latexToPlainOps(String(s||""))));

    function addBubble(role, text, opts={}){
      const row = document.createElement("div");
      row.className = `message-row ${role}` + (opts.pending ? " pending" : "");
      const bub = document.createElement("div");
      bub.className = "bubble" + (opts.kind ? ` ${opts.kind}` : "");
      const content = document.createElement("div");
      content.className = "content";

      const mode = opts.render || "plain";
      if (mode === "markdown") content.innerHTML = renderMarkdown(text);
      else if (mode === "rawHtml") content.innerHTML = text;
      else content.textContent = compactNewlines(text);

      bub.appendChild(content);
      row.appendChild(bub);
      chat.appendChild(row);
      chat.scrollTo({ top: chat.scrollHeight, behavior: "smooth" });
      return {row, bub, content};
    }

    const addUser = t => addBubble("user", t, {render:"plain"});
    const addBot  = (t,opts={}) => addBubble("bot", t, {render:"markdown", ...opts});
    function addBotPending(text="💭 잠시만 기다려주세요. 답변을 생성하고 있는 중입니다. :)"){ return addBubble("bot", text, {render:"plain", pending:true}); }
    function clearPending(p){ if (p && p.row && p.row.parentNode) p.row.remove(); }

    /* ---------- 강제 볼드(help for 선택 가이드) ---------- */
    function escReg(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
    function forceBoldCardNamesInElement(root, names){
      if(!root || !Array.isArray(names) || !names.length) return;
      const sorted=[...names].filter(Boolean).sort((a,b)=>b.length-a.length);
      const walker=document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      const toReplace=[];
      let node;
      while(node=walker.nextNode()){
        let txt=node.nodeValue;
        let changed=false;
        sorted.forEach(n=>{
          const re=new RegExp(escReg(n),'g');
          if(re.test(txt)){
            txt=txt.replace(re, '\u0000$&\u0001');
            changed=true;
          }
        });
        if(changed){
          const span=document.createElement('span');
          span.innerHTML = escapeHtml(txt).replace(/\u0000/g,'<strong>').replace(/\u0001/g,'</strong>');
          toReplace.push([node, span]);
        }
      }
      toReplace.forEach(([n,span])=>{ n.parentNode.replaceChild(span, n); });
    }

    /* ---------- RAG 답변: 버튼만 ---------- */
    function resolvePendingToRag(pendingHandle, finalMarkdown){
      if (!pendingHandle) return;
      const {row, bub, content} = pendingHandle;
      row.classList.remove("pending");
      const cleaned = latexToPlainOps(finalMarkdown);
      content.innerHTML = renderMarkdown(cleaned);

      const actions = document.createElement("div"); actions.className = "actions";
      const btnEasy = document.createElement("button"); btnEasy.className = "btn"; btnEasy.textContent = "💡 이 답변을 쉽게 설명해줘";
      const btnFollow = document.createElement("button"); btnFollow.className = "btn ghost"; btnFollow.textContent = "📝 이 답변에 대해 질문하기";
      btnEasy.onclick = async ()=>{ const fd=new FormData(); fd.append("text", content.innerText||content.textContent||""); try{ const r=await fetch("/simplify",{method:"POST",body:fd}); const d=await r.json(); addBot(d.simplified||d.message||"(빈 응답)",{render:"markdown"});}catch{ addBot("⚠️ 쉽게 설명 중 오류가 발생했어요. 잠시 후 다시 시도해 주세요."); } };
      btnFollow.onclick = ()=>{ input.placeholder="이 답변에 대해 추가 질문을 입력하세요."; input.focus(); };
      actions.appendChild(btnEasy); actions.appendChild(btnFollow); bub.appendChild(actions);
      chat.scrollTo({ top: chat.scrollHeight, behavior: "smooth" });
    }

    /* ---------- 비교 렌더 보정 ---------- */
    function boldCardNames(md, names){
      if (!Array.isArray(names) || !names.length) return md;
      const sorted = [...names].filter(Boolean).sort((a,b)=>b.length-a.length);
      let out = md;
      for (const name of sorted){
        out = out.replace(new RegExp(escReg(name), "g"), (m, offset, str)=>{
          const before = str.slice(offset-2, offset);
          const after  = str.slice(offset+m.length, offset+m.length+2);
          if (before === "**" && after === "**") return m;
          return `**${m}**`;
        });
      }
      return out;
    }
    function massageComparisonMarkdown(md, names=[], feeMap={}){
      if(!md) return md;
      md = md.replace(/\r\n/g, "\n").replace(/🏆/g, "🥇");
      md = md.replace(/^\s*📊[^\n]*/m, "📊 다음은 위에서 추천된 카드들에 대한 비교 분석 결과입니다.");
      md = md.replace(/^(💰\s*연회비:\s*)(.+)$/gm,(full,p1)=>{ for(const k of Object.keys(feeMap||{})){ if(full.includes(k)) return p1+feeMap[k]; } return full; });
      const L=md.split("\n"), out=[]; const isRank=s=>/^(🥇|🥈|🥉|4위|5위)\s*/.test(s.trim()); const isTitle=s=>/^📈\s*종합 평가/.test(s.trim())||/^💡\s*선택 가이드/.test(s.trim());
      for(let i=0;i<L.length;i++){ let ln=L[i];
        if(isRank(ln)&&ln.includes(":")){ if(out.length&&out[out.length-1].trim()!=="") out.push(""); const idx=ln.indexOf(":"); out.push(`${ln.slice(0,idx+1)} **${ln.slice(idx+1).trim()}**`); continue; }
        if(isTitle(ln)){ if(out.length&&out[out.length-1].trim()!=="") out.push(""); out.push(ln.trim()); continue; }
        out.push(ln);
      }
      return boldCardNames(out.join("\n").replace(/\n{3,}/g,"\n\n"),names);
    }
    function splitComparisonIntoChunks(md){
      const text=(md||"").replace(/\r\n/g,"\n").trim();
      const isStart=ln=>/^📊/.test(ln.trim())||/^📈\s*종합 평가/.test(ln.trim())||/^💡\s*선택 가이드/.test(ln.trim())||/^(🥇|🥈|🥉|4위|5위)\s*/.test(ln.trim());
      const lines=text.split("\n"); const chunks=[]; let buf=[];
      for(const ln of lines){ if(isStart(ln)){ if(buf.length) chunks.push(buf.join("\n").trim()); buf=[ln]; } else buf.push(ln); }
      if(buf.length) chunks.push(buf.join("\n").trim());
      return chunks.filter(Boolean);
    }
    function renderComparisonAsBubbles(comparisonMd, items){
      if(!comparisonMd) return;
      const names=(items||[]).map(x=>x.card_name).filter(Boolean);
      const feeMap={}; (items||[]).forEach(it=>{ const f=extractAnnualFeeSummary(it.card_text||""); if(f) feeMap[it.card_name]=f; });
      const prepared=massageComparisonMarkdown(comparisonMd,names,feeMap);
      splitComparisonIntoChunks(prepared).forEach(block=>{
        const h = addBot(block,{render:"markdown",kind:"comparison"});
        // 선택 가이드 등에서 굵게가 빠지는 경우를 대비한 HTML 후처리
        forceBoldCardNamesInElement(h.content, names);
      });
    }

    /* ---------- 카드 텍스트 파싱 ---------- */
    function pickField(raw,label){
      const t = raw.replace(/\r/g,'').trim();
      const re = new RegExp(label+"\\s*:\\s*([\\s\\S]*?)(?:\\n[•\\s]*[가-힣A-Za-z]+\\s*:\\s*|$)");
      const m = t.match(re); return m ? m[1].trim() : "";
    }
    function parseCardBlock(raw){
      return {
        name:pickField(raw,"카드명"), type:pickField(raw,"카드유형"), keywords:pickField(raw,"키워드"),
        brands:pickField(raw,"브랜드"), eligibility:pickField(raw,"발급대상"),
        benefits:pickField(raw,"혜택"), conditions:pickField(raw,"조건"), fees:pickField(raw,"연회비")
      };
    }

    /* ---------- 스마트 리스트 ---------- */
    const ACTION_RE = /(할인|적립|제공|제외|중복|면제|무이자|무이자할부|환급|캐시백|청구할인|청구|지원|적용|한도|까지만?)/;
    const PURE_EXCLUSION_RE = /제외/;
    const TAIL_RE = new RegExp([
      '^건당','^월\\s*최대','^월\\s*합산','^월\\s*\\d+회','^연\\s*\\d+','^전월','^리터당','^한도','^까지',
      '^제공','^적립','^포인트','^포인트리','^적용','^중복','^합산','^알뜰폰\\s*제외','^일부.*제외'
    ].join('|'));

    function tokenizeWithParens(text){
      const raw = text.replace(/\r/g,'').replace(/\u00B7/g,'·');
      const base = raw split = raw.split(/(?:,(?!\s*\d)|\n+)/).map(s=>s.trim()).filter(Boolean);
      const toks = [];
      let buf = "";
      let depthParen = 0, depthQuote = 0;
      for (let i=0;i<base.length;i++){
        const piece = base[i];
        const open = (piece.match(/\(/g)||[]).length;
        const close = (piece.match(/\)/g)||[]).length;
        const quotes = (piece.match(/["“”]/g)||[]).length;
        if (!buf){ buf = piece; depthParen += open - close; depthQuote ^= (quotes % 2);
          if (depthParen<=0 && depthQuote===0){ toks.push(buf); buf=""; depthParen=0; depthQuote=0; }
        }else{
          buf += " " + piece; depthParen += open - close; depthQuote ^= (quotes % 2);
          if (depthParen<=0 && depthQuote===0){ toks.push(buf); buf=""; depthParen=0; depthQuote=0; }
        }
      }
      if (buf) toks.push(buf);
      return toks;
    }
    const normalizeColon = tok => {
      const m = tok.match(/^([^:：]+?)\s*[:：]\s*(.+)$/);
      return m ? (m[1].trim()+': '+m[2].trim()) : tok;
    };
    function isActionToken(s){ return ACTION_RE.test(s) || /[%원\d]/.test(s); }

    function smartSplitList(str){
      if(!str) return [];
      const tokens = tokenizeWithParens(str).map(normalizeColon);

      const out=[]; let leadTails=[]; let baseTitle=null; let subjects=[]; let colonPrefix=null;
      const pushWithTails = (text)=>{
        if (!text) return;
        if (leadTails.length){ text += ' — ' + leadTails.join(' — '); leadTails=[]; }
        out.push(text);
      };

      for (let tok of tokens){
        // 1) 순수 제외 문구면 뒤꼬리
        if (TAIL_RE.test(tok) || (PURE_EXCLUSION_RE.test(tok) && !isActionToken(tok))){
          if (out.length) out[out.length-1] += ' — ' + tok;
          else leadTails.push(tok);
          continue;
        }

        // 2) "…은 …" 패턴
        const m = tok.match(/^(.+?(?:혜택|할인))\s*은\s*(.+)$/);
        if (m){
          baseTitle = m[1].trim();
          const rhs = m[2].trim();
          if (isActionToken(rhs)){
            pushWithTails(`${baseTitle}: ${rhs}`);
            baseTitle=null; subjects=[]; colonPrefix=null;
          }else{
            subjects.push(rhs);
          }
          continue;
        }

        // 3) "제목: 내용"
        const c = tok.match(/^([^:：]+):\s*(.+)$/);
        if (c){
          const title=c[1].trim(), rhs=c[2].trim();

          if (colonPrefix){ // 상위 제목이 있는 상태에서 또 등장 → 하위 주어로 흡수
            if (isActionToken(rhs)){
              const head = `${colonPrefix}: ${[...subjects, title].join(' ')}`.trim();
              pushWithTails(head ? `${head} ${rhs}` : `${title} ${rhs}`);
              colonPrefix=null; subjects=[]; baseTitle=null;
            }else{
              subjects.push(`${title} ${rhs}`.trim());
            }
            continue;
          }

          if (isActionToken(rhs)){
            pushWithTails(`${title}: ${rhs}`);
          }else{
            colonPrefix = title;
            if (rhs) subjects.push(rhs);
          }
          baseTitle=null;
          continue;
        }

        // 4) 행동 토큰이면 지금까지 누적 주어/제목을 붙여서 확정
        if (isActionToken(tok)){
          let head = '';
          if (baseTitle) head = baseTitle + (subjects.length?`: ${subjects.join(' ')}`:'');
          else if (colonPrefix) head = colonPrefix + (subjects.length?`: ${subjects.join(' ')}`:'');
          else if (subjects.length) head = subjects.join(' ');
          const line = (head? head + ' ' : '') + tok;
          pushWithTails(line);
          baseTitle=null; colonPrefix=null; subjects=[];
          continue;
        }

        // 5) 그 외는 '주어'로 누적
        subjects.push(tok);
      }

      if (baseTitle || colonPrefix || subjects.length || leadTails.length){
        let head = baseTitle || colonPrefix || '';
        let line = head ? head + (subjects.length?`: ${subjects.join(' ')}`:'') : subjects.join(' ');
        pushWithTails(line || leadTails.join(' — '));
      }

      return out;
    }

    /* ---------- 연회비 유틸 ---------- */
    function splitFeeChipsFromText(feeText){
      if(!feeText) return [];
      const base = feeText.split(/,(?!\s*\d)/).map(s=>s.trim()).filter(Boolean);
      const chips=[];
      for(let f of base){
        const parts=f.split(/\s*(?:이며|이고)\s*/).map(s=>s.trim()).filter(Boolean);
        chips.push(...(parts.length>1?parts:[f]));
      }
      return chips;
    }
    function extractFeeAmount(text){
      if(!text) return null;
      const paren=text.match(/\(([^)]*)\)/);
      if(paren && /기본|제휴/.test(paren[1])){
        const nums=[...paren[1].matchAll(/(\d[\d,]*)\s*원?/g)].map(m=>Number(m[1].replace(/,/g,'')));
        if(nums.length) return nums.reduce((a,b)=>a+b,0);
      }
      const all=[...text.matchAll(/(\d[\d,]*)\s*원/g)].map(m=>Number(m[1].replace(/,/g,'')));
      if(!all.length) return null;
      const cand=all.filter(n=>n>=5000);
      return (cand.length?Math.min(...cand):Math.max(...all));
    }
    function extractAnnualFeeSummary(raw){
      const chips=splitFeeChipsFromText(pickField(raw,"연회비")); if(!chips.length) return "";
      let best={n:Infinity,text:""}; for(const c of chips){ const n=extractFeeAmount(c); if(n!=null && n<best.n) best={n,text:c}; }
      return best.n===Infinity?chips[0]:best.text;
    }

    /* ---------- 카드 박스 렌더 ---------- */
    function renderCardBlock(d){
      const kw=d.keywords?d.keywords.split(/,(?=\s*[가-힣A-Za-z])/).map(s=>s.trim()).filter(Boolean):[];
      const br=d.brands?d.brands.split(/,(?=\s*[가-힣A-Za-z])/).map(s=>s.trim()).filter(Boolean):[];
      const tags=[...kw.map(x=>`<span class="tag">${escapeHtml(x)}</span>`),...br.map(x=>`<span class="tag">${escapeHtml(x)}</span>`)].join("");

      const meta=`<div class="card-meta">
        ${d.type?`<div class="card-kv"><span class="k">카드유형</span><span class="v">${escapeHtml(d.type)}</span></div>`:""}
        ${d.eligibility?`<div class="card-kv"><span class="k">발급대상</span><span class="v">${escapeHtml(d.eligibility)}</span></div>`:""}
      </div>`;

      const ben = smartSplitList(d.benefits||"");
      const benefits = ben.length
        ? `<section class="card-benefits"><div class="card-kv"><span class="k">혜택</span><span class="v"><ul>${ben.map(x=>`<li>${inlineMd(x)}</li>`).join("")}</ul></span></div></section>` : "";

      const cond = smartSplitList(d.conditions||"");
      const conds = cond.length
        ? `<section class="card-cond"><div class="card-kv"><span class="k">조건</span><span class="v"><ul>${cond.map(x=>`<li>${inlineMd(x)}</li>`).join("")}</ul></span></div></section>` : "";

      const feeChips = splitFeeChipsFromText(d.fees||"");
      const fees = feeChips.length
        ? `<section class="card-fee"><div class="card-kv"><span class="k">연회비</span><span class="v"><div class="fee-tags">${feeChips.map(x=>`<span class="fee">${inlineMd(x)}</span>`).join("")}</div></span></div></section>` : "";

      return `<div class="card-box">
        <h4>카드명: <strong>${escapeHtml(d.name||"카드")}</strong></h4>
        ${tags?`<div class="card-tags">${tags}</div>`:""}
        ${meta}${benefits}${conds}${fees}
      </div>`;
    }

    function enhanceCardBlocks(ctx=document){
      ctx.querySelectorAll(".card-data:not([data-enhanced])").forEach(el=>{
        const raw = el.textContent || "";
        const d = parseCardBlock(raw);
        if (!(d.name || d.type)) { el.setAttribute("data-enhanced","1"); return; }
        el.innerHTML = renderCardBlock(d);
        el.setAttribute("data-enhanced","1");
      });
    }

    /* ---------- 추천 렌더 ---------- */
    function cardDetailBlock(idx, item){
      const raw = (item.card_text||"").replace(/\s*\|\s*/g, "\n• ");
      return `
        <div class="rank">🟡 ${idx+1}. <b>${escapeHtml(item.card_name)}</b></div>
        <div class="detail"><div class="card-data">${escapeHtml(raw)}</div></div>
        <div class="pick-line"><button class="btn" data-pick="${escapeHtml(item.card_name)}">✅ ${escapeHtml(item.card_name)} 선택</button></div>`;
    }
    function renderRecommendations(items, summaryIgnored, comparisonMd){
      if (Array.isArray(items) && items.length){
        items.forEach((item, i)=>{
          const row=document.createElement("div"); row.className="message-row bot";
          const bub=document.createElement("div"); bub.className="bubble"; bub.innerHTML=cardDetailBlock(i,item);
          row.appendChild(bub); chat.appendChild(row);
          enhanceCardBlocks(bub);

          const pickBtn=bub.querySelector("[data-pick]");
          if(pickBtn){
            pickBtn.onclick=async ()=>{
              const norm=(item.card_type||"").includes("체크")?"check":"credit";
              const fd=new FormData(); fd.append("card_name",item.card_name||""); fd.append("card_type",norm); fd.append("keyword",item.keyword||"");
              const res=await fetch("/select",{method:"POST",body:fd}); const data=await res.json();
              if(data.ok){
                setStatusSelected(item.card_name||"");
                addBot(`🎯 ‘**${item.card_name}**’을(를) 선택했어요.
이제 해당 카드에 대해 질문하면 원문 기반으로 자세히 답해드릴게요.
예) "해당 카드의 주요 약관은 뭐야?" "서비스 이용 조건은 뭐야?"`,{render:"markdown"});
                input.placeholder="선택한 카드에 대해 질문하세요 (예: 연회비/혜택/조건 등)"; input.focus();
              }else{ addBot(data.message||"선택 처리에 실패했습니다.",{render:"markdown"}); }
            };
          }
        });
      }
      if(comparisonMd) renderComparisonAsBubbles(comparisonMd, items);
      chat.scrollTo({ top: chat.scrollHeight, behavior: "smooth" });
    }

    /* ---------- 서버 호출 ---------- */
    async function callRecommend(q){
      const pending = addBotPending();
      try{
        const fd=new FormData();
        fd.append("user_input", q);
        fd.append("card_type", cardTypeSel.value);
        fd.append("top_k", topK.value);
        const res=await fetch("/recommend",{method:"POST",body:fd});
        const data=await res.json();
        clearPending(pending);
        renderRecommendations(data.items, null, data.comparison);
      }catch(e){
        clearPending(pending);
        addBot("⚠️ 추천 생성 중 오류가 발생했어요. 잠시 후 다시 시도해 주세요.");
      }
    }
    async function callRag(q, mode="detailed"){
      const pending = addBotPending();
      try{
        const fd=new FormData(); fd.append("question",q); fd.append("mode",mode);
        const res=await fetch("/rag",{method:"POST",body:fd});
        const data=await res.json();
        resolvePendingToRag(pending, data.answer || data.message || "(빈 응답)");
      }catch(e){
        clearPending(pending);
        addBot("⚠️ 답변 생성 중 오류가 발생했어요. 잠시 후 다시 시도해 주세요.");
      }
    }

    /* ---------- 이벤트 ---------- */
    btnRecomm.onclick = async ()=>{
      resetSelection();
      const q=input.value.trim();
      if(q){ await callRecommend(q); }
      else{
        addBot(`다시 추천해드릴게요.  
원하는 조건을 알려주세요.  
예) **"반려동물 관련된 카드 추천해줘"**, **"병원 방문이 잦은 40대 남성에게 적합한 카드 추천해줘."**`,{render:"markdown"});
        input.focus();
      }
    };
    form.addEventListener("submit", async ()=>{
      const q=input.value.trim(); if(!q) return;
      addUser(q); input.value="";
      if(selectedCardName){ await callRag(q,"detailed"); } else { await callRecommend(q); }
    });
    input.addEventListener("keydown", async (e)=>{
      if(e.key==="Enter"&&!e.shiftKey&&!e.ctrlKey&&!e.metaKey){
        e.preventDefault();
        const q=input.value.trim(); if(!q) return;
        addUser(q); input.value="";
        if(selectedCardName){ await callRag(q,"detailed"); } else { await callRecommend(q); }
      }
    });

    document.addEventListener("DOMContentLoaded", ()=> {/* 초기 렌더 보정 */ enhanceCardBlocks(); });
  </script>
</body>
</html>
